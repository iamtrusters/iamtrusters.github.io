<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Introduction to RTOS — Caltrixia</title>
  <link href="../assets/css/style.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-okaidia.min.css" rel="stylesheet">
</head>
<body>
    <header class="site-header">
        <div class="wrap">
        <div class="brand">
            <a href="../home.html"><span class="logo">Caltrixia</span></a>
            <p class="tagline">Think deeper, Build better</p>
        </div>
        <nav class="main-nav">
          <a href="../home.html">Home</a>
          <a href="about.html">About</a>
          <a href="portfolio.html">Portfolio</a>
          <a href="contact.html">Contact</a>
        </nav>
        </div>
    </header>

  <main class="wrap content single">
    <article class="card">
      <h1>Introduction to RTOS</h1>
      <p class="meta">Feb 1, 2026 · Embedded</p>

      <p>A Real-Time Operating System (RTOS) provides deterministic scheduling and primitives that make building responsive, concurrent embedded applications easier and safer. This post gives a practical overview and best practices for working with RTOSes.</p>

      <h2>What is an RTOS?</h2>
      <p>An RTOS is an operating system designed to meet timing constraints. Key properties include predictable task scheduling, low-latency interrupt handling, and mechanisms for inter-task communication and synchronization.</p>

      <h2>Kernel types and scheduling</h2>
      <p>Kernels vary (monolithic, microkernel) but most embedded RTOSes provide:</p>
      <ul>
        <li><strong>Preemptive priority scheduling:</strong> higher-priority tasks run first; lower-priority tasks are preempted.</li>
        <li><strong>Cooperative scheduling:</strong> tasks yield explicitly (simpler, but less robust).</li>
        <li><strong>Round-robin / time-slicing:</strong> equal-priority tasks share CPU time.</li>
      </ul>

      <h2>Tasks, ISRs, and context</h2>
      <p>Tasks (threads) are the main concurrent units; ISRs handle hardware events and should be short. Avoid heavy logic in ISRs — defer processing to tasks via queues or flags.</p>

      <h2>Simple RTOS Architecture Diagram</h2>
      <div class="diagram">
        <svg width="400" height="150" viewBox="0 0 400 150">
          <rect x="20" y="50" width="80" height="50" fill="#f0f8ff" stroke="#0b5fff" stroke-width="2" rx="5" />
          <text x="60" y="75" text-anchor="middle" font-family="Inter" font-size="12">ISR</text>
          <text x="60" y="90" text-anchor="middle" font-family="Inter" font-size="10">Short</text>

          <rect x="160" y="50" width="80" height="50" fill="#f0f8ff" stroke="#0b5fff" stroke-width="2" rx="5" />
          <text x="200" y="75" text-anchor="middle" font-family="Inter" font-size="12">Task</text>
          <text x="200" y="90" text-anchor="middle" font-family="Inter" font-size="10">Work</text>

          <rect x="300" y="50" width="80" height="50" fill="#f0f8ff" stroke="#0b5fff" stroke-width="2" rx="5" />
          <text x="340" y="75" text-anchor="middle" font-family="Inter" font-size="12">Hardware</text>
          <text x="340" y="90" text-anchor="middle" font-family="Inter" font-size="10">Event</text>

          <path d="M 100 75 L 160 75" stroke="#0b5fff" stroke-width="2" marker-end="url(#arrow)" />
          <path d="M 240 75 L 300 75" stroke="#0b5fff" stroke-width="2" marker-end="url(#arrow)" />

          <defs>
            <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
              <path d="M0,0 L0,6 L9,3 z" fill="#0b5fff" />
            </marker>
          </defs>
        </svg>
      </div>

      <h2>Synchronization primitives</h2>
      <p>Common primitives provided by RTOSes:</p>
      <ul>
        <li><strong>Mutexes:</strong> mutual exclusion for shared resources.</li>
        <li><strong>Semaphores:</strong> signaling and resource counting.</li>
        <li><strong>Queues:</strong> safe message passing between ISRs and tasks.</li>
        <li><strong>Event flags/condition variables:</strong> complex synchronization patterns.</li>
      </ul>

      <h2>Priority inversion &amp; inheritance</h2>
      <p>Priority inversion happens when a low-priority task holds a resource needed by a high-priority task. Use priority inheritance or avoid long critical sections to mitigate this.</p>

      <h2>Timing, delays, and timeouts</h2>
      <p>Prefer timeouts and non-blocking APIs where appropriate. Use hardware timers for precise scheduling and avoid busy-waits unless absolutely necessary for short intervals.</p>

      <h2>Memory management</h2>
      <p>Prefer static allocation for predictability. If using dynamic allocation, choose an RTOS-aware allocator and limit runtime allocations to controlled subsystems.</p>

      <h2>Device drivers and ISR safety</h2>
      <p>Design drivers so ISRs only acknowledge hardware and queue work to tasks. Keep ISRs short and avoid calling blocking RTOS APIs from them unless the RTOS documents ISR-safe variants.</p>

      <h2>Debugging and tracing</h2>
      <p>Use tracing tools (SEGGER SystemView, FreeRTOS tracing, Zephyr Tracing) to visualize task switches, ISR timing, and scheduler behavior. Logging with minimal overhead helps diagnose timing issues.</p>

      <h2>Common RTOSes</h2>
      <ul>
        <li>FreeRTOS — widely used, small footprint.</li>
        <li>Zephyr — full-featured, modern, built for IoT.</li>
        <li>ThreadX, VxWorks, NuttX — commercial and open alternatives.</li>
      </ul>

      <h2>Quick FreeRTOS example</h2>
      <pre><code class="language-c">// Create a task (FreeRTOS - C)
void vTaskFunction(void *pvParameters) {
  for(;;) {
    // do work
    vTaskDelay(pdMS_TO_TICKS(100));
  }
}

xTaskCreate(vTaskFunction, "Worker", 256, NULL, tskIDLE_PRIORITY + 1, NULL);
</code></pre>

      <h2>Best practices checklist</h2>
      <ul>
        <li>Keep ISRs short; defer work to tasks.</li>
        <li>Prefer static allocation for deterministic behavior.</li>
        <li>Avoid long-held mutexes; keep critical sections minimal.</li>
        <li>Use queues for ISR-to-task communication.</li>
        <li>Test worst-case latencies and task interactions under load.</li>
        <li>Use tracing and deterministic timers for validation.</li>
      </ul>

      <p>RTOSes simplify building responsive embedded systems, but they introduce concurrency complexity. Follow predictable patterns, keep designs simple, and validate timing assumptions early.</p>

    </article>
  </main>

  <footer class="site-footer"><div class="wrap foot">&copy; 2026 Caltrixia</div></footer>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-c.min.js"></script>
  <script src="../assets/js/main.js"></script>
</body>
</html>