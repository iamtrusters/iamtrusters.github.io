<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Smart Pointers in C++: unique_ptr, shared_ptr, and weak_ptr ‚Äî Caltrixia</title><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet"><link href="../assets/css/style.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-okaidia.min.css" rel="stylesheet">
</head>
<body>
    <header class="site-header">
        <div class="wrap">
        <div class="brand">
            <a href="../home.html"><span class="logo">Caltrixia</span></a>
            <p class="tagline">Think deeper, Build better</p>
        </div>
        <nav class="main-nav">
          <a href="../home.html">Home</a>
          <a href="about.html">About</a>
          <a href="portfolio.html">Portfolio</a>
          <a href="contact.html">Contact</a>
          <button id="themeToggle" title="Toggle Theme">üåô</button>
          <button class="music-toggle" id="musicToggle" title="Toggle Music">‚ô™</button>
          <button id="musicNext" title="Next music type">‚è≠Ô∏è</button>
          <span id="musicType">Lofi</span>
          <input type="range" id="volumeSlider" min="0" max="1" step="0.1" value="0.5" title="Volume">
        </nav>
        </div>
    </header>

  <main class="wrap content single">
    <article class="card">
      <h1>Smart Pointers in C++: unique_ptr, shared_ptr, and weak_ptr</h1>
      <p class="meta">Feb 2, 2026 ¬∑ C++</p>

      <p>Manual memory management in C++ has long been a source of bugs, memory leaks, and undefined behavior. Smart pointers were introduced in C++11 to solve these problems by automating resource management. In this post, we'll explore the three main smart pointers: <code>unique_ptr</code>, <code>shared_ptr</code>, and <code>weak_ptr</code>, with practical examples of their use cases.</p>

      <h2>Why Smart Pointers Matter</h2>

      <p>Before smart pointers, C++ developers had to manually manage memory:</p>

      <pre><code class="language-cpp">// Manual memory management - error-prone
void processData() {
    MyClass* obj = new MyClass();
    // ... do something with obj ...

    // What if we forget this?
    delete obj;  // Memory leak if exception thrown or early return
}</code></pre>

      <p>Smart pointers ensure automatic cleanup when objects go out of scope, eliminating memory leaks and making code exception-safe.</p>

      <h2>unique_ptr: Exclusive Ownership</h2>

      <p><code>std::unique_ptr</code> represents exclusive ownership of a dynamically allocated object. Only one <code>unique_ptr</code> can own an object at a time, and ownership can be transferred but not shared.</p>

      <h3>Basic Usage</h3>

      <pre><code class="language-cpp">#include &lt;memory&gt;

std::unique_ptr&lt;int&gt; ptr = std::make_unique&lt;int&gt;(42);
std::cout &lt;&lt; *ptr &lt;&lt; std::endl;  // Outputs: 42

// Automatic cleanup when ptr goes out of scope</code></pre>

      <h3>Ownership Transfer</h3>

      <pre><code class="language-cpp">std::unique_ptr&lt;int&gt; ptr1 = std::make_unique&lt;int&gt;(100);

// Transfer ownership
std::unique_ptr&lt;int&gt; ptr2 = std::move(ptr1);

// ptr1 is now nullptr
assert(ptr1 == nullptr);
assert(*ptr2 == 100);</code></pre>

      <h3>Use Cases for unique_ptr</h3>

      <h4>1. Factory Functions</h4>

      <pre><code class="language-cpp">std::unique_ptr&lt;Connection&gt; createConnection(const std::string&amp; url) {
    // Complex initialization logic
    auto conn = std::make_unique&lt;Connection&gt;();
    conn-&gt;connect(url);
    return conn;  // Ownership transferred to caller
}

void clientCode() {
    auto connection = createConnection("tcp://example.com:8080");
    // Use connection...
    // Automatic cleanup
}</code></pre>

      <h4>2. Resource Management (RAII)</h4>

      <pre><code class="language-cpp">class FileHandler {
private:
    std::unique_ptr&lt;FILE, decltype(&amp;fclose)&gt; file_;

public:
    FileHandler(const char* filename)
        : file_(fopen(filename, "r"), fclose) {
        if (!file_) {
            throw std::runtime_error("Failed to open file");
        }
    }

    void process() {
        // File automatically closed when FileHandler is destroyed
        char buffer[1024];
        while (fgets(buffer, sizeof(buffer), file_.get())) {
            // Process buffer
        }
    }
};</code></pre>

      <h4>3. Polymorphism and Inheritance</h4>

      <pre><code class="language-cpp">class Animal { public: virtual void speak() = 0; virtual ~Animal() = default; };
class Dog : public Animal { public: void speak() override { std::cout &lt;&lt; "Woof!\n"; } };
class Cat : public Animal { public: void speak() override { std::cout &lt;&lt; "Meow!\n"; } };

std::unique_ptr&lt;Animal&gt; createPet(const std::string&amp; type) {
    if (type == "dog") {
        return std::make_unique&lt;Dog&gt;();
    } else if (type == "cat") {
        return std::make_unique&lt;Cat&gt;();
    }
    return nullptr;
}

void petShow() {
    auto pet = createPet("dog");
    pet-&gt;speak();  // Outputs: Woof!
}</code></pre>

      <h2>shared_ptr: Shared Ownership</h2>

      <p><code>std::shared_ptr</code> enables shared ownership of objects. Multiple <code>shared_ptr</code> instances can point to the same object, and the object is destroyed only when the last <code>shared_ptr</code> is destroyed.</p>

      <h3>Reference Counting</h3>

      <p><code>shared_ptr</code> uses reference counting to track how many pointers own the object:</p>

      <pre><code class="language-cpp">std::shared_ptr&lt;int&gt; ptr1 = std::make_shared&lt;int&gt;(42);
std::cout &lt;&lt; ptr1.use_count() &lt;&lt; std::endl;  // 1

std::shared_ptr&lt;int&gt; ptr2 = ptr1;
std::cout &lt;&lt; ptr1.use_count() &lt;&lt; std::endl;  // 2
std::cout &lt;&lt; ptr2.use_count() &lt;&lt; std::endl;  // 2

ptr2.reset();
std::cout &lt;&lt; ptr1.use_count() &lt;&lt; std::endl;  // 1

// Object destroyed when ptr1 goes out of scope</code></pre>

      <h3>Use Cases for shared_ptr</h3>

      <h4>1. Multiple Owners</h4>

      <pre><code class="language-cpp">class Observer {
public:
    virtual void update() = 0;
    virtual ~Observer() = default;
};

class Subject {
private:
    std::vector&lt;std::shared_ptr&lt;Observer&gt;&gt; observers_;

public:
    void addObserver(std::shared_ptr&lt;Observer&gt; observer) {
        observers_.push_back(observer);
    }

    void notify() {
        for (auto&amp; obs : observers_) {
            obs-&gt;update();
        }
    }
};

class ConcreteObserver : public Observer {
public:
    void update() override {
        std::cout &lt;&lt; "Observer notified\n";
    }
};

void observerPattern() {
    auto subject = std::make_shared&lt;Subject&gt;();
    auto observer1 = std::make_shared&lt;ConcreteObserver&gt;();
    auto observer2 = std::make_shared&lt;ConcreteObserver&gt;();

    subject-&gt;addObserver(observer1);
    subject-&gt;addObserver(observer2);

    subject-&gt;notify();  // Both observers get notified
    // All objects cleaned up automatically
}</code></pre>

      <h4>2. Caches and Flyweights</h4>

      <pre><code class="language-cpp">class Texture {
public:
    Texture(const std::string&amp; path) { /* load texture */ }
    // ...
};

class TextureManager {
private:
    std::unordered_map&lt;std::string, std::weak_ptr&lt;Texture&gt;&gt; cache_;

public:
    std::shared_ptr&lt;Texture&gt; getTexture(const std::string&amp; path) {
        // Check if texture is already loaded
        if (auto cached = cache_[path].lock()) {
            return cached;
        }

        // Load new texture
        auto texture = std::make_shared&lt;Texture&gt;(path);
        cache_[path] = texture;
        return texture;
    }
};</code></pre>

      <h4>3. Graph Structures</h4>

      <pre><code class="language-cpp">struct Node {
    int data;
    std::vector&lt;std::shared_ptr&lt;Node&gt;&gt; children;

    Node(int val) : data(val) {}
};

void buildTree() {
    auto root = std::make_shared&lt;Node&gt;(1);
    auto child1 = std::make_shared&lt;Node&gt;(2);
    auto child2 = std::make_shared&lt;Node&gt;(3);

    root-&gt;children.push_back(child1);
    root-&gt;children.push_back(child2);

    // All nodes automatically cleaned up
}</code></pre>

      <h2>weak_ptr: Breaking Reference Cycles</h2>

      <p><code>std::weak_ptr</code> is used to break circular references between <code>shared_ptr</code> objects. It doesn't contribute to the reference count and can only access the object if it still exists.</p>

      <h3>Basic Usage</h3>

      <pre><code class="language-cpp">std::shared_ptr&lt;int&gt; shared = std::make_shared&lt;int&gt;(42);
std::weak_ptr&lt;int&gt; weak = shared;

std::cout &lt;&lt; weak.use_count() &lt;&lt; std::endl;  // 1 (only the shared_ptr counts)

// Access the object
if (auto locked = weak.lock()) {
    std::cout &lt;&lt; *locked &lt;&lt; std::endl;  // 42
} else {
    std::cout &lt;&lt; "Object destroyed\n";
}</code></pre>

      <h3>Use Cases for weak_ptr</h3>

      <h4>1. Breaking Circular References</h4>

      <pre><code class="language-cpp">class Parent;
class Child;

class Parent {
public:
    std::shared_ptr&lt;Child&gt; child;
    ~Parent() { std::cout &lt;&lt; "Parent destroyed\n"; }
};

class Child {
public:
    std::weak_ptr&lt;Parent&gt; parent;  // weak_ptr to break cycle
    ~Child() { std::cout &lt;&lt; "Child destroyed\n"; }
};

void circularReference() {
    auto parent = std::make_shared&lt;Parent&gt;();
    auto child = std::make_shared&lt;Child&gt;();

    parent-&gt;child = child;
    child-&gt;parent = parent;  // weak_ptr doesn't create cycle

    // Objects are properly destroyed when they go out of scope
}</code></pre>

      <h4>2. Observer Pattern (Safe Version)</h4>

      <pre><code class="language-cpp">class Subject;

class Observer {
public:
    virtual void update() = 0;
    virtual ~Observer() = default;
};

class Subject {
private:
    std::vector&lt;std::weak_ptr&lt;Observer&gt;&gt; observers_;  // weak_ptrs

public:
    void addObserver(std::shared_ptr&lt;Observer&gt; observer) {
        observers_.push_back(observer);  // weak_ptr from shared_ptr
    }

    void notify() {
        // Remove expired observers
        observers_.erase(
            std::remove_if(observers_.begin(), observers_.end(),
                [](const std::weak_ptr&lt;Observer&gt;&amp; wp) { return wp.expired(); }),
            observers_.end()
        );

        for (auto&amp; wp : observers_) {
            if (auto obs = wp.lock()) {
                obs-&gt;update();
            }
        }
    }
};</code></pre>

      <h4>3. Cache with Automatic Cleanup</h4>

      <pre><code class="language-cpp">class Cache {
private:
    std::unordered_map&lt;std::string, std::weak_ptr&lt;Data&gt;&gt; cache_;

public:
    void store(const std::string&amp; key, std::shared_ptr&lt;Data&gt; data) {
        cache_[key] = data;
    }

    std::shared_ptr&lt;Data&gt; get(const std::string&amp; key) {
        auto it = cache_.find(key);
        if (it != cache_.end()) {
            return it-&gt;second.lock();  // May return nullptr if expired
        }
        return nullptr;
    }

    void cleanup() {
        for (auto it = cache_.begin(); it != cache_.end(); ) {
            if (it-&gt;second.expired()) {
                it = cache_.erase(it);
            } else {
                ++it;
            }
        }
    }
};</code></pre>

      <h2>Performance Considerations</h2>

      <table>
        <thead>
          <tr>
            <th>Smart Pointer</th>
            <th>Overhead</th>
            <th>Use When</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>unique_ptr</code></td>
            <td>Zero runtime cost</td>
            <td>Single ownership, performance-critical code</td>
          </tr>
          <tr>
            <td><code>shared_ptr</code></td>
            <td>Reference counting (atomic)</td>
            <td>Shared ownership, complex object graphs</td>
          </tr>
          <tr>
            <td><code>weak_ptr</code></td>
            <td>Minimal (tracks shared_ptr)</td>
            <td>Breaking cycles, optional references</td>
          </tr>
        </tbody>
      </table>

      <h2>Best Practices</h2>

      <ul>
        <li><strong>Prefer <code>std::make_unique</code> and <code>std::make_shared</code></strong> for exception safety</li>
        <li><strong>Use <code>unique_ptr</code> by default</strong> for single ownership</li>
        <li><strong>Use <code>shared_ptr</code> only when sharing is necessary</strong></li>
        <li><strong>Use <code>weak_ptr</code> to break cycles</strong> and for optional references</li>
        <li><strong>Avoid raw pointers</strong> in modern C++ code</li>
        <li><strong>Consider object ownership</strong> when choosing pointer types</li>
      </ul>

      <h2>Common Pitfalls</h2>

      <h3>Circular References</h3>

      <pre><code class="language-cpp">// BAD: Circular reference causes memory leak
class A { std::shared_ptr&lt;B&gt; b; };
class B { std::shared_ptr&lt;A&gt; a; };

// GOOD: Use weak_ptr to break the cycle
class A { std::shared_ptr&lt;B&gt; b; };
class B { std::weak_ptr&lt;A&gt; a; };</code></pre>

      <h3>Premature Optimization</h3>

      <pre><code class="language-cpp">// Don't do this for performance reasons
std::unique_ptr&lt;int&gt; ptr(new int(42));  // Less efficient

// Do this instead
auto ptr = std::make_unique&lt;int&gt;(42);  // Better exception safety</code></pre>

      <h2>Conclusion</h2>

      <p>Smart pointers are one of C++'s most important features for writing safe, maintainable code. Understanding when to use each type is crucial:</p>

      <ul>
        <li><strong><code>unique_ptr</code></strong>: For exclusive ownership and RAII</li>
        <li><strong><code>shared_ptr</code></strong>: For shared ownership and complex relationships</li>
        <li><strong><code>weak_ptr</code></strong>: For breaking cycles and optional references</li>
      </ul>

      <p>By using smart pointers appropriately, you can eliminate memory leaks, make your code exception-safe, and express ownership semantics clearly. Start with <code>unique_ptr</code> and only reach for <code>shared_ptr</code> when you truly need shared ownership.</p>

    </article>
  </main>

  <footer class="site-footer"><div class="wrap foot">&copy; 2026 Caltrixia</div></footer>

  <audio id="backgroundMusic" src="" preload="none" loop></audio>

  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-c.min.js"></script>
  <script src="../assets/js/main.js"></script>
</body>
</html></content>
<parameter name="filePath">d:\git_blog\iamtrusters.github.io\posts\2026-02-02-smart-pointers-cpp.html